# Vertex shader

> 우리 같은 사람들이 프로그래밍할 수 있는 셰이더 중 하나
> GLSL은 C와 유사해보임

```cpp
#version 330 core // 1
layout (location = 0) in vec3 aPos; // 2

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
```

GLSL을 이용할 때 아래와 같음

1. **각 셰이더는 버전 선언으로 시작**
   OpenGL 3.3 이상에서는 GLSL의 버전 번호가 OpenGL의 버전과 일치해야 함
   <br/>

2. **in 키워드를 사용해 정점 셰이더의 모든 입력 정점 속성을 선언**
   현재 위치 data에만 관심이 있으므로 단일 정점 속성만 필요
   <br/>

   GLSL에는 후위 숫자를 기준으로 1~4개의 부동 소수점을 포함하는 벡터 데이터 유형이 존재함
   <br/>

   각 정점에는 3D 좌표가 있으므로 aPos라는 이름의 vec3 입력 변수를 만듬
   <br/>

   또한 layout(location = 0)을 통해 입력 변수의 위치를 ​​구체적으로 설정했으며 나중에 해당 위치가 필요한 이유를 알게 될 것
   <br/>

---

**cf. Vector**

> 그래픽 프로그래밍에서 우리는 벡터의 수학적 개념을 자주 사용합니다.
> 벡터는 모든 공간의 위치/방향을 깔끔하게 표현하고 유용한 수학적 속성을 갖기 때문입니다.
> GLSL의 벡터는 최대 크기가 4이고 각 값은 각각 공간의 좌표를 나타내는 vec.x, vec.y, vec.z 및 vec.w를 통해 검색할 수 있습니다.
> vec.w 구성 요소는 공간의 위치로 사용되지 않지만(4D가 아닌 3D를 다루고 있음) 원근 분할이라는 항목에 사용됩니다.
> 우리는 이후 장에서 벡터에 대해 훨씬 더 깊이 있게 논의할 것입니다.

---

3. **정점 셰이더의 출력을 설정하려면 장면 뒤의 vec4인 미리 정의된 gl_Position 변수에 위치 데이터를 할당해야 함**
   주 함수의 끝에서 gl_Position을 설정한 것은 무엇이든 정점 셰이더의 출력으로 사용
   <br/>

   입력이 크기 3의 벡터이기 때문에 이를 크기 4의 벡터로 변환해야 함
   <br/>

   vec4의 생성자 내에 vec3 값을 삽입하고 w 구성 요소를 1.0f로 설정하면 되는 것
   <br/>

지금 다루는 정점 셰이더는 가장 간단한 정점 셰이더

입력 데이터에 대해 어떤 처리도 하지 않고 단순히 셰이더의 출력으로 전달했기 때문

실제 응용 프로그램에서 입력 데이터는 일반적으로 아직 정규화된 장치 좌표에 있지 않으므로 먼저 입력 데이터를 OpenGL의 가시 영역 내에 있는 좌표로 변환해야 함

## 참고

[원본](https://learnopengl.com/Getting-started/Hello-Triangle)

[블로그 참고](https://jsdysw.tistory.com/83)
